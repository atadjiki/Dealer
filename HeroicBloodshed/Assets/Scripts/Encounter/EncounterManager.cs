using System;
using System.Collections;
using System.Collections.Generic;

using Cinemachine;
using UnityEngine;
using static Constants;

public class EncounterManager : MonoBehaviour
{
    [Header("Setup Data")]
    [SerializeField] private EncounterSetupData _setupData; //setup data

    private Encounter _encounter; //generated by manager

    private void Awake()
    {
        if(_setupData != null)
        {
            SetupEncounter(_setupData);
        }
        else
        {
            Debug.Log("No encounter setup data found");
        }

    }

    public void SetupEncounter(EncounterSetupData encounterData)
    {
        StartCoroutine(Coroutine_SetupEncounter(encounterData));
    }

    private IEnumerator Coroutine_SetupEncounter(EncounterSetupData encounterData)
    {
        Debug.Log("Setting up encounter " + encounterData.name);

        _encounter = new Encounter(encounterData);

        yield return EncounterHelper.SpawnCharacters(_encounter);

        EncounterSetupComplete();
    }

    private void EncounterSetupComplete()
    {
        Debug.Log("Encounter setup complete");
    }

    //focus on the character who is currently performing an ability
    public void PrepareTurn()
    {
        CharacterComponent currentCharacter = _encounter.GetCurrentCharacter();

        //create decal
        currentCharacter.CreateDecal();

        //focus camera on character
        _encounter.SetCameraFollow(currentCharacter.transform);

        //show appropriate UI

        ProcessTurn();
    }

    //allow every team to perform an ability, then build the queues again 
    public void ProcessTurn()
    {
        //foreach team
        //foreach character in team

        TeamID CurrentTeam = _encounter.GetCurrentTeam();

        if(CurrentTeam == TeamID.Player)
        {
            ChooseCharacterAbility();
            return;
        }
        else if(CurrentTeam == TeamID.Enemy)
        {
            ChooseCharacterAbility();
            return;
        }
    }

    //non player AI will use this to determine their action for the turn 
    public void ChooseCharacterAbility()
    {

        CharacterComponent currentCharacter = _encounter.GetCurrentCharacter();

        AbilityID chosenAbility = GetAllowedAbilities(currentCharacter.GetID())[0];

        PerformCharacterAbility(chosenAbility);
    }

    //perform ability for the currently selected character
    public void PerformCharacterAbility(AbilityID abilityID)
    {
        //block input, play animation, do effects, update character data to reflect, update UI
        switch(abilityID)
        {
            default:
                Debug.Log("Performing ability " + abilityID);
                StartCoroutine(Coroutine_PerformAbility_SkipTurn());
                break;
        }
    }

    private IEnumerator Coroutine_PerformAbility_SkipTurn()
    {
        yield return new WaitForSeconds(2.5f);

        CleanupTurn();
    }

    //deselect current character before starting a new turn 
    public void CleanupTurn()
    {
        //deselect the current character 
        CharacterComponent currentCharacter = _encounter.GetCurrentCharacter();

        //destroy any decals
        currentCharacter.DestroyDecal();

        //recenter camera
        _encounter.ResetCameraFollow();

        //pop the current character from the queue 
        _encounter.PopCurrentCharacter();

        //update the encounter state 
        UpdateState();
    }

    public void UpdateState()
    {
        _encounter.IncrementTurnCount();

        //check if we are done with this team 
        if (_encounter.IsCurrentTeamQueueEmpty())
        {
            Debug.Log(_encounter.GetCurrentTeam() + " team done");

            if(_encounter.IncrementTeam() == TeamID.None)
            {
                //if all teams have gone, then time to rebuild queues
                _encounter.BuildTeamQueues();
                return;
            }
        }

        PrepareTurn();
    }
}
